ðŸ Python is a high-level, versatile programming language that's designed to be easy to read, write, and understand
-> Python is Dynamic :-No Type Declaration Needed You donâ€™t need to say what type a variable is
EG:
x = 5         # Python treats 'x' as an integer
x = "hello"   # Now 'x' is a string
ðŸ§± In Python, it requires indentation .
ðŸPython Interpreter & Shell (REPL)
->Python is an interpreted language, which means it executes code line by line using an interpreter.
ðŸ’» Shell
Refers to the interface or tool where the REPL happens.
When you type python or python3 in the terminal and see >>>, you're inside the Python Shell.
ðŸ§ª REPL (Readâ€“Evalâ€“Print Loop)
REPL stands for:
ðŸ“¥ Read your input (the Python code you type)
ðŸ¤– Evaluate the code
ðŸ“¤ Print the result
ðŸ” Loop back and wait for the next command

ðŸ› ï¸ Useful Methods & Functions in Python REPL
ðŸ§® Built-in Functions
These work anywhere â€” including REPL!
>print() â€“ display output
>type() â€“ check the type of a variable
>len() â€“ get the length of strings, lists, etc.
>Input() â€“ capture user input
>abs() â€“ absolute value
>round() â€“ round a number
>max(), min() â€“ find highest/lowest values
>sum() â€“ total values in a list or tuple
>sorted() â€“ return a sorted version of a sequence
>help() â€“ get help on any object or module
>dir() â€“ list attributes/methods of object

ðŸ§  PEP 8
->ðŸ“˜ PEP 8 (Python Enhancement Proposal 8) is the official style guide for writing clean and consistent Python code.
ðŸ§¼ 1. Code Layout
Use 4 spaces per indentation level (avoid tabs unless configured properly).
Keep each line within 79 characters for better readability.
Separate top-level functions and classes using 2 blank lines to organize code visually.
ðŸ§¬ 2. Naming Conventions
1)snake_case (variables, functions, methods, modules):
This involves using lowercase letters for all words and separating them with underscores. For example: my_variable, calculate_area, process_data.
2)PascalCase (classes):
Each word in the class name starts with a capital letter, with no underscores. For example: MyClass, HTTPResponse, BankAccount.
3)ALL_CAPS (constants):
All letters are capitalized, and words are separated by underscores. For example: MAX_CONNECTIONS, PI, DEBUG_MODE.

ðŸ§  Static vs Dynamic Typing â€” Key Concepts
ðŸ”’ Statically Typed Languages
Definition: Type of each variable is determined at compile time.

Type Declaration: Often required by the programmer (e.g., int x = 10; in C). Some modern statically typed languages support type inference (e.g., Kotlin, Scala, Haskell).

Error Checking: The compiler performs strict type checking before execution â€” reducing runtime errors.

Common Use Cases: Large, complex systems where safety and performance matter (e.g., enterprise software, systems programming).

Examples: C, C++, Java, Rust, Go, Scala, Kotlin, Haskell

âœ… Advantages
Catch type errors early in the development cycle

Better tooling, optimization, and IDE support

Easier to enforce contracts and interfaces across teams

ðŸ”“ Dynamically Typed Languages
Definition: Variable types are determined at runtime, based on the actual data held.

Type Declaration: Not required â€” the interpreter assigns types on the fly.

Flexibility: Allows faster development and prototyping but may lead to hidden bugs if types change unexpectedly.

Common Use Cases: Scripting, automation, rapid app development, small to medium-sized projects.

Examples: Python, JavaScript, Ruby, PHP, Perl, Erlang

âœ… Advantages
Quick and flexible coding â€” ideal for beginners or fast iterations

Cleaner syntax and fewer boilerplate declarations

Excellent for interactive use (e.g., REPL environments)

ðŸ” Summary of Differences
Feature	Static Typing	Dynamic Typing
Type Checking	Compile-time	Runtime
Type Declaration	Required or inferred	Optional and runtime-determined
Error Detection	Before execution	During execution
Development Speed	Slower, more structured	Faster, more flexible
Common Languages	C, C++, Java, Rust, Scala	Python, JavaScript, PHP, Ruby

ðŸ§® 1. Arithmetic Operators
Used for basic mathematical calculations:

+  # Addition
-  # Subtraction
*  # Multiplication
/  # Division
%  # Modulus (remainder)
/ /  # Floor Division
**  # Exponentiation

ðŸ” 2. Assignment Operators
Used to assign values:

=    # x = 5
+=   # x += 3  (x = x + 3)
-=   # x -= 2
*=   # x *= 4
/=   # x /= 2
%=   # x %= 3
**=  # x **= 2
//=  # x //= 5

ðŸ” 3. Comparison Operators
Used for logical comparisons:

==   # Equal to
!=   # Not equal to
>    # Greater than
<    # Less than
>=   # Greater than or equal to
<=   # Less than or equal to

ðŸ’¡ 4. Logical Operators
Used to combine conditional statements:

->and   # Both conditions are true
->or    # At least one condition is true
->not   # Reverses the result (True to False)

ðŸ”¢ 5. Bitwise Operators
Operate on binary representations:

&    # AND
|    # OR
^    # XOR
~    # NOT
<<   # Shift left
>>   # Shift right

ðŸ§­ 6. Membership Operators
Used to check presence in a sequence:

->in      # Checks if value exists in a sequence
->not in  # Checks if value does NOT exist

ðŸ§· 7. Identity Operators
Used to compare memory locations:

->is      # Returns True if both refer to same object
->is not  # Returns True if they donâ€™t

ðŸ§  String
->A string is a sequence of characters enclosed in quotes.
->Python supports single ', double ", and triple quotes ''' or """.
âœ¨ 2. String Properties
->mmutable: You cannot change characters in place.
->Indexed & Sliced: Supports indexing (s[0]) and slicing (s[1:5]).
->Iterable: You can loop through a string.

ðŸ§ª 3. Useful String Methods
Method	Description	Example

capitalize()	Capitalizes first character
casefold()	Aggressive lowercase for comparison
center(width)	Centers string with padding
count(sub)	Counts how many times substring occurs
encode()	Encodes string to bytes
endswith(suffix)	Checks if string ends with suffix
expandtabs(tabsize)	Replaces \t with spaces
find(sub)	First index of substring (or -1)
format()	Formats string with placeholders
format_map(mapping)	Uses dictionary to format string
index(sub)	First index of substring (raises error if not found)
isalnum()	Returns True if all characters are alphanumeric
isalpha()	Returns True if all characters are alphabetic
isascii()	Returns True if all characters are ASCII
isdecimal()	Returns True if all characters are decimal digits
isdigit()	Returns True if all characters are digits
isidentifier()	Returns True if string is valid Python identifier
islower()	Returns True if all characters are lowercase
isnumeric()	Returns True if all characters are numeric
isprintable()	Returns True if all characters are printable
isspace()	Returns True if all characters are whitespace
istitle()	Returns True if string is title-cased
isupper()	Returns True if all characters are uppercase
join(iterable)	Joins elements using the string as separator
ljust(width)	Left-justifies string in field of given width
lower()	Converts string to lowercase
lstrip()	Removes leading whitespace (or characters)
maketrans()	Builds translation table for use with translate()
partition(sep)	Splits string into 3 parts around separator
replace(old, new)	Replaces all instances of old with new
rfind(sub)	Last index of substring (or -1)
rindex(sub)	Last index (raises error if not found)
rjust(width)	Right-justifies string
rpartition(sep)	Like partition() but starts from end
rsplit(sep)	Splits from right side
rstrip()	Removes trailing whitespace (or characters)
split(sep)	Splits string by separator
splitlines()	Splits string into lines
startswith(prefix)	Checks if string starts with prefix
strip()	Removes leading and trailing whitespace (or characters)
swapcase()	Swaps case of each character
title()	Converts string to title case
translate(table)	Translates characters using mapping table
upper()	Converts string to uppercase
zfill(width)	Pads string with zeros on the left



ðŸ” 5. String Operators
+ â†’ concatenation
* â†’ repetition
in / not in â†’ membership
== / != â†’ comparison

âœ‚ï¸ 6. Slicing & Indexing
python
s = "Python"
s[0]        # 'P'
s[-1]       # 'n'
s[1:4]      # 'yth'
s[::-1]     # 'nohtyP' (reverse string)

ðŸ§± 7. Escape Characters
\n â€“ newline
\t â€“ tab
\\ â€“ backslash
\' or \" â€“ quotes inside string

what is array?
 An array is a data structure used to store a collection of itemsâ€”typically of the same typeâ€”in a single, organized unit. 
Itâ€™s like a row of labeled boxes where each box holds a value and you can access them by index. ðŸ“¦

ðŸ“¦ What Is a Structured Array?
A structured array is a type of NumPy array where each element can have multiple fields, like a row in a database or a record in a table. 
Each field has a name and its own data type.
EG-[ ('Alice', 25, 5.5), ('Bob', 30, 6.1), ... ]
Where each row has:
A name (string),
An age (integer),
A height (float)
âœ… Benefits of Structured Arrays
->You can store and work with tabular data efficiently.
->Each column (field) can have its own type.
->Helpful for data analysis, machine learning, and working with datasets.

LIST 
ðŸ§¾ Definition:
->A list is an ordered collection of items, which can be changed (mutable), and it allows duplicate values.

 ðŸŽ¯ Key Features of Lists
Feature	      Description
Ordered	      | Items stay in the same order you added them
Mutable	      | You can change items, add, or remove them
Heterogeneous	| Can store different types: strings, numbers, even other lists
Indexed	      | Access items using positions starting from 0
Allows Duplicates	| [1, 2, 2, 3] is valid

âž• Add & Insert
Method	                     Description	                      Example
append(x)	          Add x to the end of the list	          my_list.append(4)
extend(iterable)	   Add elements from another iterable	    my_list.extend([6, 7])
insert(i, x)	       Insert x at index i	                   my_list.insert(1, 10)

âŒ Remove Items
Method            	Description	                          Example
remove(x)	       Removes first occurrence of x          	my_list.remove(2)
pop(index)      	Removes and returns item at index i    	my_list.pop(0) â†’ returns 1
clear()	         Empties the entire list               	 my_list.clear()
pop()            removes element from the last

ðŸ” Search & Analyze
Method	           Description	                                 Example
index(x)	    Returns index of first x	                     my_list.index(3)
count(x)	    Counts how many times x appears    	          my_list.count(2)
in           keyword Checks if item exists	                2 in my_list â†’ True
len()        provides total no of elements present in list

ðŸ” Sort & Reverse
Method	       Description	                     Example
sort()	      Sorts list in ascending order	   my_list.sort()
reverse()    Reverses the listâ€™s order	       my_list.reverse()

ðŸ“Œ Max() and Min()
max() returns the largest value from a list or iterable.
min() returns the smallest value from a list or iterable.
->ðŸ”¹ Using key Parameter:
You can use key= to customize how values are compared.
words = ["hi", "hello", "hey"]
print(max(words, key=len))  # â†’ hello
print(min(words, key=len))  # â†’ hi

# List comprehension
squares = [x**2 for x in range(5)]  # â†’ [0, 1, 4, 9, 16]

ðŸ§  Tuples 
ðŸ”¹ What Is a Tuple?
->A tuple is an immutable, ordered sequence of elements.
->Defined using parentheses () or without them (but comma is essential).

EG:
t1 = (1, 2, 3)
t2 = 1, 2, 3  # also a tuple

ðŸ”¹ Key Properties
Feature	                         Description
Ordered                	Maintains insertion order
Immutable	              Cannot change after creation
Allow Duplicates       	Yes
Can Store Mixed Types  	Yes (int, str, list, etc.)

ðŸ”¹Tuple Creation
Empty tuple: t = ()
Single element: t = (5,) (comma is necessary)
Nested tuples: t = (1, (2, 3), 4).

ðŸ”¹Accessing Elements
Indexing: t for the first element, t[-1] for the last.
Slicing: t[1:4] gives a new tuple with elements from index 1 to 3.
Nested access: t[1] for nested tuples.

ðŸ”¹Basic Tuple Operations
Operation              	Example                       	Description
Concatenation        	(1,2) + (3,4)	                  Combine tuples
Repetition	           ('a',)*3	                       Repeat tuple
Slicing	              t[1:3]	                         Extract a sub-tuple
Membership	           'a' in t	                       Check if an item exists
Length               	len(t)	                         Number of elements
Unpacking	            a, b = (1, 2)	                  Assign tuple elements to variables

ðŸ”¹Tuple Functions & Methods
Function/Method     Purpose                     	            Example
len(t)	             Returns the number of items	             len((1,2,3)) â†’ 3
max(t)             	Returns the largest item	                max((1,3,2)) â†’ 3
min(t)              Returns the smallest item	               min((1,3,2)) â†’ 1
sum(t)             	Returns the sum of elements(if numeric)	 sum((1,2,3)) â†’ 6
count(x)	           how many times "x" appears               (1,2,2,3).count(2) â†’ 2
index(x)	           Returns first index of x	                (1,2,3).index(2) â†’ 11
sort() Method       modifies the original list               SYNTAX = list(sorted(TUP1,key=None, reverse=False)
zip()               to pair up elements from all tuples

 #IF TUPLE CONVERTED TO LIST ,IT CAN BE CHANGED OR MUTABLE
ðŸ”¹Tuple Packing and Unpacking in Python
1. Tuple Packing
->Definition: Packing is the process of combining multiple values into a single tuple.
->How: Assigning multiple comma-separated values to a single variable automatically creates a tuple.

2. Tuple Unpacking
->Definition: Unpacking extracts the individual elements of a tuple into separate variables.
->Requirement: The number of variables on the left must match the number of elements in the tuple,
unless using extended unpacking.

3. Extended Unpacking with *
->Allows capturing multiple elements into a list during unpacking.
->Useful when the number of variables is fewer than the number of tuple elements.

ðŸ”¹Python range() 
What is range()?
The range() function generates an immutable sequence of integers.
It is commonly used for looping a specific number of times or generating a sequence of numbers.
SYNTAX:
range(stop)
range(start, stop)
range(start, stop, step)

ðŸ”¹Tuple comprehension
->Tuple comprehension	Not supported directly	(x for x in iterable) is a generator
->Imitate with list comp	tuple([x for x in iterable])	Creates tuple from list comprehension
->Imitate with generator	tuple(x for x in iterable)	Creates tuple from generator expression

Tuple Comprehension in Python: Accurate Notes
1. No Direct Tuple Comprehension Syntax
Python does not support direct tuple comprehension like list, set, or dictionary comprehensions.
Writing (x for x in iterable) creates a generator expression, not a tuple.
This is because tuples are immutable and cannot be built incrementally like lists or sets.

2. How to Create Tuples Using Comprehension-Like Syntax
You can imitate tuple comprehension by using:
List comprehension inside the tuple() constructor, or
Generator expression inside the tuple() constructor.


ðŸ”‘key Function()
The key parameter is used in functions like sorted(), max(), min(), etc.,
to specify a function that will be applied to each element before comparison.
-> DEFINES ON WHAT BASIS ? 
EG : key == len # means to operate on basis of length

ðŸ§±SETS
->Unordered, mutable collection of unique elements
->Defined with curly braces {} or using set() constructor
->Duplicate elements are automatically removed
EG:
A = {1, 2, 3}
B = set([2, 3, 4])
 
âž• Adding Elements to a Set
1)add() â€“ Adds a single element
EG:
A = {1, 2}
A.add(3)
# A becomes {1, 2, 3}

2)update() â€“ Adds multiple elements (from list, set, tuple, etc.)
EG:
A.update([4, 5])
# A becomes {1, 2, 3, 4, 5}

âž– Removing Elements from a Set
3)remove() â€“ Removes specific item (error if not found)
EG:
A.remove(2)  # KeyError if 2 not in A

4)discard() â€“ Removes item if present (no error if not)
EG:
A.discard(10)  # Safe even if 10 is not in A

5)pop() â€“ Removes and returns a random element
EG:
val = A.pop()  # Element removed randomly

6)clear() â€“ Removes all elements
EG:
A.clear()

ðŸ§® Set Operations  
Operation            	                Syntax	                                    Description
Union(ALL ELEMENTS)              `A  orA.union(B)`                      	  Combines all elements
Intersection(COMMON IN BOTH)  	   A & B or A.intersection(B)	              Common elements only
Difference                       	A - B or A.difference(B)	                Items in A but not in B
Symmetric Diff(UNIQUE ELEMENTS)	  A ^ B or A.symmetric_difference(B)    	  Items in A or B but not both
Subset Check	                     A <= B or A.issubset(B)                 	A is contained in B
Superset Check	                   A >= B or A.issuperset(B)	               B is contained in A
Disjoint Check	                   A.isdisjoint(B)	                         No common elements

1ï¸âƒ£ Union â€“ Combines all unique elements
EG:
A = {1, 2, 3}
B = {3, 4, 5}

print("Union:", A | B)  # or A.union(B)
# Output: {1, 2, 3, 4, 5}
âœ… Useful for merging datasets without duplicates.

2ï¸âƒ£ Intersection â€“ Finds common elements
EG:
print("Intersection:", A & B)  # or A.intersection(B)
# Output: {3}
âœ… Helps find overlap in choices, preferences, or results.

3ï¸âƒ£ Difference â€“ Elements in A not in B
EG:
print("A - B:", A - B)  # or A.difference(B)
# Output: {1, 2}
âœ… Great for finding unique entries or exclusions.

4ï¸âƒ£ Symmetric Difference â€“ Elements in either set but not both
EG:
print("Symmetric Difference:", A ^ B)  # or A.symmetric_difference(B)
# Output: {1, 2, 4, 5}
âœ… Identifies mismatches or disjoint items.

5ï¸âƒ£ Subset & Superset Checks
EG:
C = {1, 2}
print("C is subset of A:", C.issubset(A))      # True
print("A is superset of C:", A.issuperset(C))  # True
âœ… Important in permissions, group hierarchies, and filtering.

6ï¸âƒ£ Disjoint Check â€“ No common elements
EG:
D = {10, 11}
print("A and D are disjoint:", A.isdisjoint(D))  # True

 ðŸ§  Quick Notes for Interviews
->Sets are unordered, so indexing/slicing doesn't work.
->Use sets for membership tests, duplicate removal, and fast comparisons.
->set() on a string or list removes duplicates.
->Ideal for solving problems like:
->Finding unique items
->Checking overlap
->Counting distinct values

ðŸ§  Set Comprehension
->Set comprehension is a concise way to create sets from iterable data sources using a single line of code, following the pattern:
->SYNTAX:
{expression for item in iterable if condition}

->Similar to list comprehension, but uses {} to build a set
->Automatically removes duplicates
->Only includes items that meet the specified condition

ðŸ§  Basic Built-in Functions for Sets
Function          	Description
len(set)	          Returns number of elements
max(set)	          Largest value in set
min(set)	          Smallest value in set
sum(set)	          Sum of all elements
sorted(set)	       Returns sorted list
any(set)	          True if at least one item is truthy
all(set)	          True if all items are truthy
enumerate(set)    	Returns index-value pairs
list(set)	         Converts set to list
tuple(set)        	Converts set to tuple

ðŸ§ŠFrozenset
->Itâ€™s an immutable set â€” once created, you canâ€™t change it.
->Like a regular set, it stores unique, unordered elements.
->Can be used as a dictionary key or element in another set (regular sets cannot).
EG:
fs = frozenset([1, 2, 3, 2])
print(fs)  # Output: frozenset({1, 2, 3})

âœ… Key Features
Property	             Regular Set	              Frozenset
Mutable	              âœ… Yes                   	âŒ No
Hashable	             âŒ No                    	âœ… Yes
Allows duplicates	    âŒ No	                    âŒ No
Uses curly braces	    âœ… Yes	                   âŒ No (use frozenset())

ðŸ”’ What You CAN Do with a Frozenset
1)len(fs) â€“ Count items

2)min(fs), max(fs) â€“ Get smallest/largest

3)fs.union(...), fs.intersection(...), fs.difference(...) â€“ Set operations

4)fs.isdisjoint(...), fs.issubset(...), fs.issuperset(...)

ðŸš« What You CANâ€™T Do
1)No add(), remove(), pop(), clear()

2)No updates â€” itâ€™s frozen!

âœ… Examples of Hashable Types
Type     	Hashable?	    Can be Dict Key?
int	      âœ”ï¸ Yes	       âœ”ï¸ Yes
float	    âœ”ï¸ Yes	       âœ”ï¸ Yes
str      	âœ”ï¸ Yes	       âœ”ï¸ Yes
tuple	    âœ”ï¸ Yes (only if all elements are hashable)	âœ”ï¸ Yes
frozenset	âœ”ï¸ Yes	        âœ”ï¸ Yes
list	     âŒ No         	âŒ No
dict	     âŒ No	         âŒ No
set	      âŒ No	         âŒ No

ðŸ§  Dictionary 
->A dictionary is a built-in Python data structure that stores data as key-value pairs.
->Keys must be unique and immutable (e.g., strings, numbers, tuples).
->Values can be of any data type, including other dictionaries.
->From Python 3.7+, dictionaries maintain insertion order.

SYNTAX:
{key1: value1, key2: value2, ...}
EG:
my_dict = {'name': 'Alice', 'age': 30, 'skills': ['Python', 'SQL']}

ðŸ”‘ Key Characteristics of Python Dictionaries
Characteristic	                   Description
1)Mutable	                   You can add, update, or delete items after creation.
2)Ordered (Python â‰¥ 3.7)    	Maintains insertion order of items.
3)Uniqueness	                Keys must be unique; duplicate keys overwrite previous values.
4)Immutability	              Keys must be immutable types (e.g., strings, numbers, tuples).
5)Value Flexibility	         Values can be of any data type, including other dictionaries.
6)Fast Lookup	               Uses hashing for constant-time access to values via keys.
7)Indexed by Keys	           Accessed using keys, not numerical indices like lists.
8)Case Sensitivity	          Keys are case-sensitive: 'Name' and 'name' are treated as different

ðŸ› ï¸ Common Operations
1) Creating a dictionary
person = {'name': 'Alice', 'age': 30}

2) Accessing values
i>print(person['name'])           # Output: Alice
ii>print(person.get('city', 'N/A'))  # Output: N/A

3) Adding/updating
person['city'] = 'Indore'

4) Removing items
i>del person['age']
ii>person.pop('city')
iii>person.clear()  # Removes all items

ðŸ§° Dictionary Methods
Method	          Description
->clear()	         Removes all items
->copy()	          Returns a shallow copy
->fromkeys()	      Creates dictionary from keys with default value
->get(key)	        Returns value for key or None if not found
->items()	         Returns view object of key-value pairs
->keys()	          Returns view object of keys
->values()	        Returns view object of values
->pop(key)	        Removes item with specified key and returns its value
->popitem()	       Removes and returns last inserted key-value pair
->setdefault()	    Returns value of key; inserts key with default if not found
->update()	        Updates dictionary with another dictionary or iterable of key-value pairs

ðŸ” Basic Iteration Techniques
1. Iterate Over Keys (Default Behavior)
EG:
my_dict = {'a': 1, 'b': 2, 'c': 3}
for key in my_dict:
    print(key)
This loops through all the keys in the dictionary.

2. Iterate Over Keys Explicitly
EG:
for key in my_dict.keys():
    print(key)
Same as above, but more explicit.

3. Iterate Over Values
EG:
for value in my_dict.values():
    print(value)
Loops through all the values.

4. Iterate Over Key-Value Pairs
EG:
for key, value in my_dict.items():
    print(f"{key}: {value}")
Most common way to access both keys and values simultaneously.

ðŸ§ª Advanced Iteration Techniques

5. Using enumerate() for Index Tracking
EG:
for index, (key, value) in enumerate(my_dict.items()):
    print(f"{index}: {key} -> {value}")

6. Using zip() to Pair Keys and Values
EG:
for key, value in zip(my_dict.keys(), my_dict.values()):
    print(f"{key}: {value}")

7. Dictionary Comprehension
EG:
squared = {key: value**2 for key, value in my_dict.items()}
Creates a new dictionary by applying logic during iteration.


ðŸ”¹Method	        Removes...	                    Returns...	               Error if Missing?
i)pop(key)	      Specific key-value pair	       Value	                    Yes (unless default)
ii)popitem()	    Last inserted item	            Tuple(key, value)	        Yes (if empty)


â­Merging Two Dictionary

ðŸ”§ 1. update() Method

EG:
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}

dict1.update(dict2)
print(dict1)  # {'a': 1, 'b': 3, 'c': 4}

->Modifies dict1 in place.
->Overwrites values if keys overlap.

ðŸ§© 2. Dictionary Unpacking (**)

EG:
dict3 = {**dict1, **dict2}
Creates a new dictionary.

->Available from Python 3.5+.
->Later keys overwrite earlier ones.

ðŸ§± 3. Merge Operator (|)

EG:
dict3 = dict1 | dict2
Introduced in Python 3.9+.

->Returns a new dictionary.
->Overlapping keys take values from the right-hand dictionary.

ðŸ” 4. Loop-Based Merge

EG:
merged = dict1.copy()
for k, v in dict2.items():
    merged[k] = v

->Useful for custom merge logic.
->Works in all Python versions.

ðŸ§ Nested Dictionary
->A nested dictionary is a dictionary where values themselves are dictionaries. This structure allows you to represent hierarchical or grouped data.

EG:
students = {
    "student1": {"name": "Ariana", "age": 20, "grade": "A"},
    "student2": {"name": "Travis", "age": 22, "grade": "B"}
}

ðŸ› ï¸ Creating Nested Dictionaries
1. Direct Assignment
EG:
data = {
    "item1": {"price": 100, "stock": 20},
    "item2": {"price": 150, "stock": 35}
}

2. Using Loops
EG:
nested = {}
for i in range(3):
    nested[i] = {"value": i * 10}


3)ðŸ” Accessing Elements
EG:
print(students["student1"]["name"])  # Output: Ariana
print(students.get("student2", {}).get("grade", "N/A"))  # Output: B
Use .get() to avoid KeyError when accessing nested keys.

4)âœï¸ Modifying Nested Dictionaries
EG:
students["student1"]["grade"] = "A+"
students["student3"] = {"name": "Luna", "age": 21, "grade": "A"}

5)âŒ Deleting Elements
EG:
del students["student2"]["age"]       # Remove inner key
del students["student3"]              # Remove entire entry

6)ðŸ” Iterating Through Nested Dictionaries
EG:
for student_id, info in students.items():
    print(f"\n{student_id}:")
    for key, value in info.items():
        print(f"  {key}: {value}")

ðŸ§­ Dictionary Key Sorting in Python (No lambda, No def)

âœ… 1. Basic: Sort by Keys (Ascending Order)
EG:

d = {'c': 3, 'a': 1, 'b': 2}
sorted_dict = dict(sorted(d.items()))
Uses sorted() on .items()

->Automatically sorts by keys
->Converts back to dictionary using dict()

âœ… 2. Sort by Keys in Descending Order
EG:

sorted_dict = dict(sorted(d.items(), reverse=True))
->reverse=True sorts keys from highest to lowest

âœ… 3. Sort Dictionary by Keys using List Comprehension
EG:

sorted_dict = {k: d[k] for k in sorted(d)}
->Creates a new dict sorted by keys (ascending)
->Efficient for quick logic without .items()

EXPLANATION:

d = {'banana': 3, 'apple': 1, 'cherry': 2}

->What's Happening Step-by-Step:
->sorted(d) gives you a sorted list of keys: ['apple', 'banana', 'cherry']
->For each key k, you grab its value using d[k]
->{k: d[k] for ...} builds a new dictionary, one key-value pair at a time
->Done! You now have a sorted dictionary: {'apple': 1, 'banana': 3, 'cherry': 2}

âœ… 4. Sort Dictionary by Keys with Comprehension (Descending)
EG:

sorted_dict = {k: d[k] for k in sorted(d, reverse=True)}
->Works the same as above, but in reverse key order


ðŸ”¢ Dictionary Value Sorting Techniques
Letâ€™s use this sample dictionary:
EG:
d = {'apple': 40, 'banana': 10, 'cherry': 25}

âœ… 1. Using operator.itemgetter() (No lambda, No def)
EG:

import operator
sorted_dict = dict(sorted(d.items(), key=operator.itemgetter(1)))
Grabs the second item (value) from each pair

reverse=True adds descending order

âœ… 2. Using lambda (Inline Function)
EG:

sorted_dict = dict(sorted(d.items(), key=lambda item: item[1]))
Most commonly used in quick scripts

Can sort by custom logic too (item[1] % 10, etc.)

âœ… 3. Using def Function (Custom Key Extractor)
EG:

def get_value(pair):
    return pair[1]

sorted_dict = dict(sorted(d.items(), key=get_value))
Clearer when sorting logic is reused or complex

Supports descending with reverse=True

âœ… 4. Using Dictionary Comprehension
EG:

sorted_dict = {k: v for k, v in sorted(d.items(), key=lambda item: item[1])}
Wraps sorted result into a new dictionary

Descending: reverse=True in sorted()

âœ… 5. Sorting Only Values (No Keys)
EG:

sorted_values = sorted(d.values())
Returns list of values in order

Doesnâ€™t retain key association â€” more useful for value analysis

âœ… 6. Sort Dictionary with Nested Values
EG:

nested = {
    'item1': {'score': 82},
    'item2': {'score': 96}
}

import operator
sorted_nested = dict(sorted(nested.items(), key=lambda x: x[1]['score']))
Sorts based on inner field like 'score'

ðŸ Python Functions 
->Python functions are reusable blocks of code designed to perform a specific task. 
->They help in modularizing code, improving readability, and reducing redundancy.
->They help break big problems into smaller parts and are very useful in real-world programming

ðŸ” Key Concepts
1. Function Definition
EG:
def function_name(parameters):
    # code block
    return result
->def: Keyword to define a function
->function_name: Identifier for the function
->parameters: Optional inputs
->return: Optional output

2. Function Calling
EG:
function_name(arguments)

3. Types of Functions
->Built-in functions: len(), print(), type(), etc.
->User-defined functions: Created using def
->Lambda functions: Anonymous, single-expression functions

4. Arguments
->Positional arguments: Based on order
->Keyword arguments: Specified by name
->Default arguments: Have default values
->Variable-length arguments:
  *args: Non-keyword variable arguments
  **kwargs: Keyword variable arguments

5. Return Statement
->Returns a value from the function.The return statement is used inside a function to send a result back to the caller. 
->It also ends the functionâ€™s execution immediately.
->Can return multiple values as a tuple
EG:
def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # Output: 8

âš ï¸ Important Notes
-> after a return statement wonâ€™t run.
->You can use multiple return statements in a function, but only one will execute depending on the logic.
->Functions always return somethingâ€”either a value or None.

ðŸ’¡ Best Practices
->Use return to make your functions reusable and testable.
->Avoid using print() inside functions when you need to use the result elsewhereâ€”use return instead.
->Document what your function returns using docstrings.

6. Scope
->Local scope: Variables inside a function
->Global scope: Variables outside all functions
->Use global keyword to modify global variables inside a function

7. Docstrings
->Used for documentation.
->A docstring (short for documentation string) is a special kind of string used to describe 
->what a function, class, or module does. It helps others (and your future self!) understand your code.
SYNTAX : " " OR """ """
EG:
def greet():
    """This function greets the user."""
    print("Hello!")

ðŸ§©pass Func()
->It does nothing when executed.
->Itâ€™s used to avoid errors in places where Python expects a statement.
->Commonly used in empty functions, classes, loops, or conditionals.


ðŸ”¢ Positional Arguments
->These are arguments passed to a function in the exact order the parameters are defined.

âœ… Example:
def greet(name, age):
    print(f"Hello {name}, you are {age} years old.")

greet("Alice", 25)  # 'Alice' goes to name, 25 goes to age

->The first value goes to the first parameter, the second to the second, and so on.
->Order matters â€” swapping values can lead to unexpected results.

ðŸ·ï¸ Keyword Arguments
->These are passed by explicitly naming the parameter, so order doesnâ€™t matter.
âœ… Example:

def greet(name, age):
    print(f"Hello {name}, you are {age} years old.")

greet(age=25, name="Alice")  # Works fine!
 
->You specify which value goes to which parameter.
->Makes the function call more readable and flexible.

ðŸ”€ Mixing Positional and Keyword Arguments
->You can mix both, but positional arguments must come first.
âœ… Valid:
greet("Alice", age=25)

âŒ Invalid:
greet(age=25, "Alice")  # SyntaxError: positional argument follows keyword argument

ðŸ’¡ Best Practices
->Use positional arguments when the meaning is obvious and order is clear.
->Use keyword arguments for clarity, especially with many parameters.
->Avoid mixing too many types unless necessary.

ðŸ§©Default Arguments
->Default arguments are values you assign to function parameters in advance,
->so if the caller doesnâ€™t provide them, Python uses the defaults.

ðŸ” Example:
def show_info(name, city="Hyderabad"):
    print("Name:", name)
    print("City:", city)

show_info("Ansh", "Delhi")   # Output: Name: Ansh, City: Delhi
show_info("Shrey")           # Output: Name: Shrey, City: Hyderabad
In the second call, city wasnâ€™t provided, so it used the default "Hyderabad".

âš ï¸ Important Rules
->Default arguments must come after non-default ones.
EG:
def func(a, b=2):  # âœ… Valid
def func(a=1, b):  # âŒ Invalid

->You can override defaults by passing values explicitly.
->Be careful with mutable defaults like lists or dictionariesâ€”they persist across calls!

ðŸ“¦ Variable-Length Arguments in Python
->Variable-length arguments allow functions to accept a flexible number of inputs. Python provides two ways:
->*args for non-keyword (positional) arguments
->**kwargs for keyword arguments

âœ… 1. *args â€“ Arbitrary Positional Arguments
ðŸ”¹ Purpose:
->Allows a function to receive any number of positional arguments, packaged as a tuple.

ðŸ”¹ Syntax:
def function_name(*args):
    # args is a tuple

ðŸ”¹ EG:
def add_all(*numbers):
    return sum(numbers)

->add_all(1, 2, 3, 4)  # Output: 10

ðŸ”¹ Notes:
->You can iterate over args using a loop.
->Useful when argument count may vary.

âœ… 2. **kwargs â€“ Arbitrary Keyword Arguments
ðŸ”¹ Purpose:
->Allows a function to receive any number of keyword arguments, packed as a dictionary.

ðŸ”¹ Syntax:
def function_name(**kwargs):
    # kwargs is a dict

ðŸ”¹ EG:
def display_info(**details):
    for key, value in details.items():
        print(f"{key}: {value}")

display_info(name="Alice", age=25)

ðŸ”¹ Notes:
->Use .items() to access keys and values.
->Useful for flexible configuration or optional parameters.

ðŸ”€ Combining *args and **kwargs
->You can use both in the same function, but the order matters.

EG:
def example_func(arg1, *args, **kwargs):
    print("arg1:", arg1)
    print("args:", args)
    print("kwargs:", kwargs)
ðŸŽ¯ Rule: *args must come before **kwargs

âš ï¸ Best Practices & Tips
->Name them clearly (*args, **kwargs) for convention, but you can rename (e.g., *items, **options).
->Use when writing utility functions, wrappers, or building APIs.
->Handle them carefully to avoid confusion between fixed and flexible parameters.
->Use default values or validation when needed.

ðŸ§ª Interview Questions & Examples
Question	Sample Answer
What is *args used for?	Accepts extra positional arguments in a function.
What does **kwargs return?	A dictionary of keyword arguments.
Can you use both together?	Yes. Syntax: def func(a, *args, **kwargs)
How are values accessed in **kwargs?	Using .items() method for key-value pairs.

ðŸ§  Quick Summary
Type	What It Does	Stored As
Positional	Matches values by order	Variables
Keyword	Matches values by parameter name	Variables
*args	Packs extra positional arguments	Tuple
**kwargs	Packs extra keyword arguments	Dictionary

ðŸ” Recursive Functions in Python
âœ… What Is Recursion?
->Recursion is when a function calls itself to solve a smaller version of the same problem.
->It continues until it reaches a base case, which stops the recursion.

ðŸ§© Structure of a Recursive Function
def recursive_function(parameters):
    if base_case_condition:
        return result
    else:
        return recursive_function(modified_parameters)

->Base Case: Stops the recursion.
->Recursive Case: Calls the function again with updated input.

ðŸ” Example: Factorial Using Recursion
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))  # Output: 120

->factorial(5) calls factorial(4), then factorial(3), and so on until factorial(0).

ðŸ§  Key Concepts
Term	                 Meaning
Base Case	            Condition where recursion stops (e.g., n == 0)
Recursive Case	       Function calls itself with smaller input (e.g., factorial(n-1))
Stack	                Each recursive call is stored in memory until the base case is reached
RecursionError       	Happens if recursion goes too deep without stopping

âœ… lambda Function OR Anonymous Function()

->In Python, an anonymous function is created using the lambda keyword.
->Itâ€™s called â€œanonymousâ€ because itâ€™s defined without a name.
->These are typically used for small, short-lived functions.
->Think of lambda as a compact way to write small functions, especially when you don't want to use a full def block.
EG:
1)
add = lambda x, y: x + y
print(add(3, 5))  # Output: 8

2)ðŸŒ€ Sorting with lambda:
data = [('apple', 3), ('banana', 1), ('cherry', 2)]
sorted_data = sorted(data, key=lambda x: x[1])
print(sorted_data)  # Sorted by number

ðŸ§¹filter()
->The filter() function is used to filter items out of an iterable (like a list or tuple) based on a condition.
->It returns only the elements that satisfy the condition provided by a function.

ðŸ› ï¸ Syntax

filter(function, iterable)
->function: A function that returns True or False
->iterable: The collection you want to filter (e.g. list, tuple)
->It returns a filter objectâ€”you often convert this to a list like list(filter(...)).

->SIMPLY:filter() takes a function (like a lambda) and an iterable (like a list), and keeps only the items where the function returns True.

âœ… Examples
1. Filter Even Numbers

nums = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # Output: [2, 4, 6]



